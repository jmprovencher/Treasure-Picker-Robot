Afin de contrôller les roues, la première étape est d'alimenter correctement chacun des moteurs des roues. Le pont en H connecté aux moteurs nécessite trois entrées par roue: deux entrées servent à sélectionner la direction des roues, et une troisième reçoit un PWM déterminant la vitesse de rotation de la roue.

Le pont en H est alimenté à l'aide d'une alimentation 5V, ce qui pour les fins de la démonstration est fait directement à partir d'une sortie de l'Arduino Mega. Les encodeurs des roues en tant que tels sont par contre doivent être alimentés à une tension entre 3.5 et 20V, temporairement fourni à l'aide d'une source murale. Selon les spécifications du pont en H, la pin 1 de chaque moteur doit reçevoir une tension faible et la pin 2 une tension élevée pour tourner la roue associée dans le sens des aiguilles d'une montre. Afin de tourner dans le sens inverse, il faut alors utiliser une tension élevée sur 1 et faible sur 2. Un des premiers tests est alors effectué, avec le pont en H alimenté et les quatres roues à pleine vitesse. À l'aide de ce test, il fut facile de voir que le branchement des roues de même orientation devrait être de deux sens opposés, car le sens des aiguilles signifie une rotation différente d'un côté à l'autre du robot.

Par la suite, en utilisant des sorties PWM de l'Arduino Mega, des ondes carrées à rapport cyclique de 50\% sont envoyées en sortie. Celles-ci, lorsque connectées aux entrées de vitesse correspondant aux quatres moteurs dans le pont en H, permettent de comparer la vitesse des moteurs et de vérifier si celle-ci est consistente. Résultat de ce test: en activant deux roues à la fois, le robot ne va pas en ligne droite. Le moteur 1 fait tourner la roue significativement plus rapidement que le moteur 3 avec la même commande. Un asservissement avec intégrateur est donc absolument nécessaire afin que la vitesse de chaque roue rejoigne la consigne, permettant au robot de rouler en ligne droite.

La librarie PID disponible sur le Playground Arduino permet de rapidement implémenter un asservissement avec une durée d'échantillonage, une commande à rejoindre et des paramètres kp, ki et kd définis par l'utilisateur. Pour implémenter la commande à rejoindre, les encodeurs des moteurs sont branchés directement à des entrées numériques du microcontrôlleur Arduino. En effet, ceux-ci génèrent une onde carrée à largeur variable, celle-ci pouvant être lue en utilisant la fonction pulseIn(). La durée de lecture maximale (timeout) de la largeur d'impulsion est à la base très lente, environ une seconde par lecture, ce qui rend l'asservissement peu efficace si le robot tourne lentement. Pour remédier à cette situation, un timeout de 3 ms a été choisi.

Avec pulseIn, lorsqu'aucune onde n'est détectée avant la fin du temps maximal, une valeur de 0 est retournée. Hors, l'asservissement fonctionne avec un principe que lorsque la durée retournée par pulseIn est supérieure à la commande, il faut augmenter la sortie vers les moteurs. Afin d'assurer qu'une roue à l'arrêt ne soit pas considérée comme impossiblement rapide, une valeur de 0 est remplacée par la durée maximale de lecture, soit 3 ms.

Les tests initiaux de l'asservissement étaient peu fructueux. En effet, la sortie du PID variait beaucoup trop rapidement entre minimum et maximum, ne permettant que très peu de précision. Ceci était dû à un kp trop élevé, ce qui multipliait l'erreur bien au delà de la valeur maximale du paramètre du PWM, soit 255. En diminuant l'élément proportionnel kp à 0.0005 au lieu de 1, la variation cyclique due à un trop large dépassement est évitée. Le ki est présentement à 0.25 car il permet de rejoindre la consigne suffisemment rapidement sans créer de trop larges dépassements.

\begin{figure}[htp]
	\centering
	\includegraphics[width=1\textwidth]{fig/communicationArduino.png}
	\caption{Test de rotation sur deux roues, commande à rejoindre de 800 microsecondes de largeur d'impulsion}
	\label{f:test_Arduino}
\end{figure}

Dans l'état actuel de ce sous-système, il y a dépassement en vitesse de plus de 10\% pendant environ une seconde. Afin de permettre des déplaements plus précis, du travail sera fait pour diminuer ce dépassement. Pour communiquer à l'Arduino Mega la ccomnsigne à rejoindre, une interruption sur le port série est implémentée en utilisant serialEvent. Lorsque le port série détecte qu'il y a quelque chose à lire sur le port série, le code de lecture de la commande prend alors priorité sur l'exécution du PID.