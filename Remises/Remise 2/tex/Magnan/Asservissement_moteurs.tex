Afin de contrôller les roues, la première étape était d'alimenter correctement chacun des moteurs des roues. Le pont en H connecté aux moteurs nécessite trois entrées par roue: Deux entrées servant à sélectionner la direction des roues, et une troisième étant un PWM déterminant la vitesse de rotation de la roue.

Le pont en H doit être alimenté avec 12V, ce qui pour les fins de la démonstration est fait avec une source murale. Les roues en tant que telles sont par contre alimentées à une tension de 5V, Selon les spécifications du pont en H, la pin 1 doit reçevoir une tension faible et la pin 2 une tension élevée pour tourner dans le sens des aiguilles d'une montre, le sens inverse étant obtenu avec une tension élevée sur 1 et faible sur 2. Un des premiers tests est alors effectué, avec le pont en H alimenté et les quatres roues à pleine vitesse. À l'aide de ce test, il fut facile de voir que le branchement des roues de même sens devrait être inversé, car le sens des aiguilles signifie une rotation différente d'un côté à l'autre du robot.

Par la suite, en utilisant des sorties PWM de l'Arduino Mega, des ondes carrées à rapport cyclique de 50\% sont envoyées en sortie. Celles-ci, lorsque connectées aux entrées de vitesse correspondant aux quatres moteurs dans le pont en H, permettent de comparer la vitesse des moteurs et de vérifier si celle-ci est consistente. Résultat de ce test: en activant deux roues à la fois, le robot ne va pas en ligne droite. Le moteur 1 fait tourner la roue significativement plus rapidement que le moteur 3 avec la même commande. Un asservissement avec intégrateur est donc absolument nécessaire afin que la vitesse de chaque roue rejoigne la consigne, permettant au robot de rouler en ligne droite.

La librarie PID disponible sur le Playground Arduino permet de rapidement implémenter un asservissement avec une durée d'échantillonage, une commande à rejoindre et des paramètres kp, ki et kd étant défini par l'utilisateur. Pour implémenter la commande à rejoindre, les encodeurs des moteurs sont branché directement au microcontrôlleur Arduino. En effet, ceux-ci génèrent une onde carrée à largeur variable, la longueur de celle-ci pouvant être lue en utilisant la fonction pulseIn(). La durée de lecture maximale (timeout) de la largeur d'impulsion est à la base très lente, environ une seconde par lecture, ce qui rend l'asservissement lent si le robot tourne lentement. Pour remédier à cette situation, un timeout de 3 ms a été choisi.

Avec pulseIn, lorsqu'aucune onde n'est détectée avant la fin du temps maximal, une valeur de 0 est retournée. Hors, l'asservissement fonctionne avec un principe que lorsque la durée retournée par pulseIn est supérieure à la commande, il faut augmenter la sortie vers les moteurs. Afin d'assurer qu'une roue à l'arrêt ne soit pas considérée comme impossiblement rapide, une valeur de 0 est remplacée par la durée maximale de lecture, soit 3 ms.

Les tests initiaux de l'asservissement étaient peu fructueux. En effet, la sortie du PID variait beaucoup trop rapidement entre minimum et maximum, ne permettant que très peu de précision. Ceci était dû à un kp trop élevé, ce qui multipliait l'erreur bien au delà de la valeur maximale du paramètre du PWM, soit 255. En diminuant l'élément proportionnel kp à 0.0005 au lieu de 1, la variation cyclique due à un trop large dépassement est évitée. Le ki est présentement à 0.25 car il permet de rejoindre la consigne suffisemment rapidement sans créer de trop larges dépassements.

Dans l'état actuel de ce sous-système, il y a dépassement en vitesse de plus de 10\% pendant environ une seconde. Afin de permettre des déplaements plus précis, du travail sera fait pour diminuer ce dépassement. Pour communiquer à l'Arduino Mega la ccomnsigne à rejoindre, une interruption sur le port série est implémentée en utilisant serialEvent. Lorsque le port série détecte qu'il y a quelque chose à lire sur le port série, le code de lecture de la commande prend alors priorité sur l'exécution du PID.